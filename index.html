<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Software Modeling and Design quiz</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            padding: 30px;
            width: 100%;
            max-width: 900px;
        }

        h1 {
            color: #333;
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .question-container {
            margin-bottom: 20px;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #444;
        }

        .answer-container {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 5px;
            font-size: 1.1rem;
            line-height: 1.5;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px; /* Verhoogde padding */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 5px; /* Aangepaste margins */
            font-size: 1.2rem; /* Grotere lettergrootte */
            width: calc(100% - 10px);
            max-width: 400px; /* Verhoogde max-width */
            transition: background-color 0.3s ease;
            min-height: 60px; /* Minimale hoogte toegevoegd */
        }

        button:hover {
            background-color: #45a049;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 5px;
            font-size: 1rem;
        }

        .progress {
            margin-top: 10px;
            background-color: #ddd;
            border-radius: 5px;
            height: 20px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
            border-radius: 5px;
            transition: width 0.5s ease-in-out;
        }

        /* Responsive design voor verschillende schermgroottes */
        @media screen and (min-width: 768px) {
            .container {
                padding: 40px;
            }

            h1 {
                font-size: 2.5rem;
            }

            h2 {
                font-size: 1.8rem;
            }

            button {
                width: auto;
                margin: 10px;
                min-height: 50px; /* Aangepaste minimale hoogte voor desktop */
            }
        }

        @media screen and (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.3rem;
            }

            .answer-container {
                padding: 10px;
                font-size: 1rem;
            }

            button {
                padding: 15px 25px; /* Grotere padding voor mobiel */
                font-size: 1.2rem; /* Grotere lettergrootte voor mobiel */
                margin: 10px 0; /* Aangepaste margins voor mobiel */
                width: 100%; /* Volledige breedte op mobiel */
                min-height: 70px; /* Grotere minimale hoogte voor mobiel */
            }
        }

        /* Donkere modus ondersteuning */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #fff;
            }

            .container {
                background-color: #333;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            }

            .answer-container {
                background-color: #444;
            }

            .stats {
                background-color: #3a3a3a;
            }

            h1, h2 {
                color: #fff;
            }

            button {
                background-color: #5cb85c;
            }

            button:hover {
                background-color: #4cae4c;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Software Modeling and Design Quiz</h1>
    <div class="question-container">
        <h2 id="question"></h2>
        <button onclick="showAnswer()">Toon Antwoord</button>
    </div>
    <div id="answer" class="answer-container"></div>
    <button onclick="nextQuestion()">Volgende Vraag</button>
    <div class="stats">
        <p>Vragen: <span id="questionsStatus">0 van 0</span></p>
        <p>Voortgang deze ronde: <span id="progress">0</span>%</p>
        <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </div>
</div>

<script>
    const questions = [
        {
            question: "Wat zijn de drie categorieën van modules in Requirement Analysis?",
            answer: "<ul><li>A-modules</li><li>B-modules</li><li>C-modules</li></ul>"
        },
        {
            question: "A-modules",
            answer: "Technieken voor het definiëren van functionele en niet-functionele vereisten en het ontwerpen van een applicatie"
        },
        {
            question: "B-modules",
            answer: "Geavanceerde datamodellering"
        },
        {
            question: "C-modules",
            answer: "OO-modellering met UML"
        },
        {
            question: "Wat vertegenwoordigt een requirement in een Information System?",
            answer: "Een behoefte die het Information System moet vervullen, zoals <br>Functionaliteiten, <br>Niet-functionele vereisten of <br>Omgevingsgebonden beperkingen (bijvoorbeeld juridische restricties)."
        },
        {
            question: "Wat is een functioneel requirement?",
            answer: "Een vereiste die beschrijft wat de software of component moet doen. Het proces is iteratief."
        },
        {
            question: "Wat is een case model?",
            answer: "Een tool om functionele vereisten te bepalen tijdens de analyse en het ontwerp, die ook dient als basis voor testen, communicatie tussen betrokkenen en documentatie."
        },
        {
            question: "Wat bevat een case model?",
            answer: "Een use case diagram met meerdere use cases en use case beschrijvingen."
        },
        {
            question: "Wat is een systeemgrens in een case model?",
            answer: "Een rechthoek met de naam van het systeem binnen of boven de rechthoek, wat het startpunt van de requirements analyse aangeeft."
        },
        {
            question: "Wat is een actor in een use case diagram?",
            answer: "Een entiteit buiten het systeem die het systeem gebruikt of ermee communiceert. Een actor is altijd een rol, geen naam, en kan een persoon, organisatie of systeem zijn. (Start met hoofdletter)"
        },
        {
            question: "Wat is een use case?",
            answer: "Een 'case' waarvoor een actor het systeem wil gebruiken, een doel dat één of meerdere actoren met het systeem willen bereiken. werkwoord + zelfstandig naamwoord (vb. Enter Order)"
        },
        {
            question: "Wat is het verschil tussen een brief, casual en fully dressed use case?",
            answer: "<li>Brief use case 1 alinea die de use case samenvat.</li><li>Casual use case: Meerdere alinea's die de use case samenvatten.</li><li>Fully dressed use case: Een formeel document met een gedetailleerde structuur en velden voor verschillende secties.</li>"
        },
        {
            question: "Hoe beschrijf je functionaliteit in een casual use case?",
            answer: "In de vorm van een user story, bijvoorbeeld: \"Als student kan ik me inschrijven voor een college.\""
        },
        {
            question: "Wat beschrijf je in het \"Normal flow\" gedeelte van een use case?",
            answer: "Het successcenario waarbij wordt beschreven wat de actor en het systeem doen na het kiezen van de functionaliteit."
        },
        {
            question: "Wat beschrijf je in het \"Alternatives\" gedeelte van een use case?",
            answer: "Alternatieve scenario's die kunnen optreden, waarbij voor elk alternatief 1 paragraaf wordt gebruikt."
        },
        {
            question: "Wat zijn de twee hoofdtypes van vereisten in requirements analysis?",
            answer: "<li>Functioneel: Wat de gebruiker wil dat het systeem doet.</li><li>Niet-functioneel: Voorwaarden waaronder de functionaliteiten moeten worden aangeboden, zoals prijs, installatievoorwaarden, beveiliging en prestaties.</li>"
        },
        {
            question: "Wat is de rol van een use case diagram?",
            answer: "Het geeft een overzicht van de functionele vereisten (use cases) voor elke type gebruiker en toont de interacties tussen de actoren en het systeem."
        },
        {
            question: "Wat zijn preconditions in een use case?",
            answer: "Voorwaarden die moeten worden vervuld voordat een actor de functionaliteit kan gebruiken, zoals inloggen in het systeem."
        },
        {
            question: "Hoe beschrijf je een alternatieve stroom in een use case?",
            answer: "Je beschrijft alternatieve scenario's die kunnen optreden, elk met een korte naam en een beschrijving van wat er anders is dan het normale verloop."
        },
        {
            question: "Wat zijn de kenmerken van een fully dressed use case?",
            answer: "Het is een formeel document met een gedetailleerde structuur en velden voor verschillende secties, vaak gebruikt in grote en kritische projecten."
        },
        {
            question: "Wat is het belang van het iteratieve proces in requirements analysis?",
            answer: "Het stelt ontwikkelaars in staat om gedurende de tijd meer vereisten te ontdekken en te verfijnen naarmate het project vordert, waardoor de kwaliteit en volledigheid van het eindproduct worden verbeterd."
        },
        {
            question: "Wat zijn de interacties tussen actor en systeem in een use case?",
            answer: "Dit zijn de afwisselende acties en reacties tussen de actor en het systeem, waarbij de actor acties onderneemt en het systeem daarop reageert zonder interne implementatiedetails te onthullen."
        },
        {
            question: "Wat zijn enkele voorbeelden van technische foutcontroles die niet in use case beschrijvingen moeten worden opgenomen?",
            answer: "<li>Datum formaat fout</li><li>Verkeerde invoer van tekst in plaats van een nummer</li><li>Niet ingevulde verplichte velden</li>"
        },
        {
            question: "Hoe beïnvloeden juridische restricties de requirements analysis?",
            answer: "Juridische restricties zijn omgevingsgebonden vereisten die bepalen wat het systeem moet respecteren of naleven, wat van invloed kan zijn op de functionele en niet-functionele vereisten van het systeem."
        },
        {
            question: "Waarom is documentatie belangrijk in het requirements analysis proces?",
            answer: "Documentatie biedt een basis voor communicatie tussen alle betrokken partijen, dient als referentie tijdens de ontwikkeling en testing, en helpt bij het vastleggen van de beslissingen en vereisten gedurende het project."
        },
        {
            question: "Wat zijn de twee types van actors?",
            answer: "Actieve actor<br>Passieve actor"
        },
        {
            question: "Actieve actor",
            answer: "Start de communicatie en begint een use case (bijvoorbeeld: Student of Docent aan de linkerkant van het model)."
        },
        {
            question: "Passieve actor",
            answer: "Het systeem start de communicatie en neemt deel (bijvoorbeeld: mailbox van de student aan de rechterkant van het model)."
        },
        {
            question: "Wat betekent het wanneer een actor iets erft in de context van requirements analysis? (inheritance)",
            answer: "De actor die erft kan ALLES doen wat de actor waarvan geërfd wordt kan doen.<img src=/Resources/Inheritance.JPG alt='inheritance'>"
        },
        {
            question: "Wat is de betekenis van \"extend\" in een use case?",
            answer: "Het geeft aan dat extra gedrag wordt toegevoegd aan het gedrag van een use case. Dit extra gedrag wordt optioneel geïmplementeerd en gemodelleerd in een nieuwe use case. In het diagram wordt dit aangegeven door een onderbroken pijl met de stereotype &quot;&lt;&lt;extend&gt;&gt;&quot;.<img src=/Resources/Extend.JPG alt='extend'>"
        },
        {
            question: "Wat betekent \"include\" in een use case?",
            answer: "Het geeft aan dat deze use case gebruikmaakt van een andere use case, waardoor het gedrag van de eerste use case verandert. Dit extra gedrag wordt altijd uitgevoerd en is essentieel voor het succes van de eerste use case.<img src=/Resources/Include.JPG alt='include'>"
        },
        {
            question: "Hoe ziet de benaming van een Use-case er uit",
            answer: "einddoel, niet de apparte stappen werkwoord + zelstandig naamwoord, start met hoofdletter"
        },
        {
            question: "Veel gemaakte fouten in Use case description",
            answer: "- Beschrijf hoe het gedraagd, niet hoe het gestructureerd is<br>- Beschrijf events, geen user interface zoals buttons, dropdowns,...<br>- Beschrijft interacties tussen actoren en systeem, niet tussen actoren onderling<br>- Geen technische error checks"
        },
        {
            question: "Waar en hoe wordt de extend beschreven in de use case diagram?",
            answer: "In de use case waar de extend aan vast hangt komt een extra lijntje bij alternatieve trajecten waar dan de beschrijving bij staat als de gebruiker,..schakelt het systeem over naar de use case \"...\", voor deze extand use case wordt dan een apparte use case description gemaakt die uitlegt wat die doet zoals bij een gewone use case."
        },
        {
            question: "Waar en hoe wordt de include beschreven in de use case diagram?",
            answer: "Bij de hoofd Use Case waar de include bij hoort wordt in de Normal flow op het correcte moment in het process vermeld: The system switches to the use case \"...\" en gaat dan verder met wat er na deze stap gebeurt in de use case. Er is een apparte use case description die de Include Use case uitlegd"
        },
        {
            question: "Welke niveaus van use cases zijn er?",
            answer: "1 Cloud/wolk<br>2 Kite/vlieger<br>3 Sea/zee<br>4 Fish/vis<br>5 Clam/schelp<br><img src=/Resources/Levels%20of%20use%20cases.JPG alt='Levels Of Use Case'>"
        },
        {
            question: "Cloud Level use case",
            answer: "Gebruiksscenario's op dit hoogste niveau vertegenwoordigen vaak groepen onderling verbonden bedrijfsprocessen, zoals het Verkopen van Producten."
        },
        {
            question: "Kite Level use cases",
            answer: "Op dit tweede niveau worden individuele bedrijfsprocessen meestal gepost, vaak gericht op workflows."
        },
        {
            question: "Sea Level use cases",
            answer: "Dit is het niveau dat ertoe doet, en dat ook het Wijzigen van Adres omvat, bijvoorbeeld. Gebruiksscenario's op zeeniveau vertegenwoordigen de interactie tussen een gebruiker en een systeem. Het resultaat van zo'n gebruiksscenario vervult een doelstelling van het systeem. De tijd die nodig is om zo'n gebruiksscenario te verwerken, varieert doorgaans van enkele minuten tot een half uur."
        },
        {
            question: "Fish Level use cases",
            answer: "Gebruiksscenario's op Fish-niveau worden gebruikt om zelfstandige functionaliteit te modelleren die Sea-niveau ondersteunt. Denk bijvoorbeeld aan Abonnement Ophalen of Product Selecteren."
        },
        {
            question: "Clam Level use cases",
            answer: "Soms modelleren projecten te ver vooruit, en worden de gebruiksscenario's te klein. Dit wordt Clam-niveau genoemd."
        },
        {
            question: "Kiss principe",
            answer: `
    <ul>
      <li>Keep it simple, stupid...</li>
      <li>Keep it short and simple</li>
      <li>Keep it simple & straightforward</li>
      <li>Keep it smart & simple</li>
      <li>Communication</li>
      <li>Maintainability</li>
      <li>Frames in agile software development: "baby steps"...</li>
    </ul>
  `
        },
        {
            question: "Wat zijn secundaire use cases?",
            answer: "Secundaire use cases ondersteunen de primaire use cases. Ze bieden functionaliteiten die nodig zijn om de hoofdfunctionaliteiten mogelijk te maken, zoals \"Login\" of \"Activate login\"."
        },
        {
            question: "Wat zijn primaire use cases?",
            answer: "Primaire use cases zijn de meest belangrijke taken die het systeem moet uitvoeren voor de actor. Ze vervullen een gebruikersdoel, ondersteunen een taak die zelfstandig staat, is compleet en kan in één sessie met het systeem worden voltooid."
        },
        {
            question: "Hoe worden secundaire use cases weergegeven in een use case diagram?",
            answer: "In het use case diagram staan secundaire use cases tussen de primaire use cases. Na het voltooien van het diagram is er geen onderscheid meer zichtbaar tussen primaire en secundaire use cases."
        },
        {
            question: "Wanneer worden secundaire use cases gecreëerd tijdens het analyseproces?",
            answer: "Tijdens het analyseproces worden eerst de primaire use cases gemaakt en pas daarna de secundaire use cases."
        },
        {
            question: "Wat gebeurt er als een docent een evaluatiecriterium wil verwijderen dat al gebruikt is in evaluaties?",
            answer: "Het evaluatiecriterium wordt niet verwijderd, maar de status wordt op \"inactive\" gezet."
        },
        {
            question: "Wat is een oplossing voor het omgaan met historische data in het systeem?",
            answer: "Toon alleen de huidige of actieve data bij het ondersteunen van nieuwe procesuitvoeringen, gebaseerd op datum of status.<br>Historische data wordt niet gewist omdat het altijd nog nuttig kan zijn, het wordt op inactief gezet in plaats van gewist"
        },
        {
            question: "Wat is prototyping?",
            answer: "Prototyping is het proces van het maken van prototypes, die experimentele en incomplete ontwerpen zijn die snel en goedkoop ontwikkeld kunnen worden."
        },
        {
            question: "Wat zijn de belangrijkste kenmerken van een prototype?",
            answer: "Prototypes zijn experimenteel, incompleet, kunnen snel worden ontwikkeld en zijn relatief goedkoop."
        },
        {
            question: "Wat is het primaire doel van prototyping?",
            answer: "Het visualiseren van visies en ideeën om waardevolle gebruikersfeedback te verkrijgen op een ontwerp."
        },
        {
            question: "Geef een voorbeeld van hoe prototyping wordt toegepast bij het ontwerpen van een applicatie.",
            answer: "Bij het ontwerpen van een applicatie kan prototyping worden toegepast door schermontwerpen te maken die de gebruikersinterface weergeven."
        },
        {
            question: "Wat zijn de voordelen van prototyping?",
            answer: "<li>Stimuleert vroege feedback.</li><li>Vermindert het risico op grote wijzigingen achteraf, die aanzienlijk duurder zijn.</li><li>Verhoogt het aantal iteraties, wat leidt tot regelmatige verbeteringen en een risicoreducerend effect heeft.</li>"
        },
        {
            question: "Hoe draagt prototyping bij aan het verminderen van risico's in het ontwerpproces?",
            answer: "Door het aantal iteraties te verhogen, wat leidt tot regelmatige verbeteringen en het tijdig identificeren en oplossen van problemen."
        },
        {
            question: "Waarom is vroege feedback essentieel in het prototypingproces?",
            answer: "Vroege feedback helpt om ontwerpfouten vroeg te identificeren en aan te passen voordat ze kostbaar worden om te corrigeren."
        },
        {
            question: "Wat zijn de drie hoofdtypen prototypes?",
            answer: "Low-fidelity (LO-FI)<br>Medium-fidelity (ME-FI) <br>High-fidelity (HI-FI)"
        },
        {
            question: "Beschrijf een Low-Fidelity prototype.",
            answer: "Een LO-FI prototype schetst de algemene structuur van de gebruikersinterface, met focus op schermindeling en ontwerpconcepten, zonder aandacht voor details zoals kleur of lettertype"
        },
        {
            question: "Wat onderscheidt een Medium-Fidelity prototype van een Low-Fidelity prototype?",
            answer: "Een ME-FI prototype is geavanceerder, wordt op de computer gemaakt en kan verschillende benaderingen hebben, zoals verticale, horizontale en scenario-gebaseerde prototyping."
        },
        {
            question: "Welke drie benaderingen zijn mogelijk binnen Medium-Fidelity prototyping?",
            answer: "Verticale prototyping (beperkt aantal functies met diepgaande functionaliteit), horizontale prototyping (volledige gebruikersinterface zonder functionaliteit),&nbsp; scenario-gebaseerde prototyping (beperkt aantal functies en functionaliteit)."
        },
        {
            question: "Wat zijn de kenmerken van een High-Fidelity prototype?",
            answer: "HI-FI prototypes gebruiken materiaal dat vergelijkbaar of identiek is aan het eindproduct, zijn visueel zeer compleet en interactief, wat gebruikers kan misleiden om te denken dat er al een volledig functionerend systeem is."
        },
        {
            question: "Wat zijn de voordelen van Low-Fidelity prototypes?",
            answer: "<li>Snel en goedkoop te maken.</li><li>Ondersteund natuurlijke vorm van communicatie tussen stakeholders</li><li>Kan makkelijk elk moment aangemaakt worden.</li><li>Focus op belangrijke elementen zoals structuur.</li><li>Geen speciale kennis vereist.</li><li>Bevordert samenwerking</li>"
        },
        {
            question: "Wat zijn de nadelen van Low-Fidelity prototypes?",
            answer: "<li>Niet interactief.</li><li>Geen functionaliteit (beperkingen in flow en navigatie).<br></li><li>Niet mogelijk te kopieren</li><li>Moeilijk om aanpassingen te maken</li><li>Geen ontwerpgeheugen</li><li>Geen mogelijkheid tot codegeneratie.</li>"
        },
        {
            question: "Wat zijn de voordelen van Medium-Fidelity prototypes?",
            answer: "- Interactief<br>- bruikbaar voor testen en evaluaties<br>- bruikbaar als marketingtool"
        },
        {
            question: "Wat zijn de nadelen van Medium-Fidelity prototypes?",
            answer: "- Hogere ontwikkelkosten (tijd)<br>- Focus op details<br>- Geen codegeneratie"
        },
        {
            question: "Wat zijn de voordelen van High-Fidelity prototypes?",
            answer: "<li>Volledige weergave van de User Interface</li><li>Interactief en bruikbaar voor tests en evaluaties.</li><li>Kan code genereren of andere weergaven</li><li>Kan als marketingtool worden gebruikt.</li><li>Layout-eigenschappen kunnen gemakkelijk worden gedefinieerd.</li>"
        },
        {
            question: "Wat zijn de nadelen van High-Fidelity prototypes?",
            answer: "<li>Gedrag moeilijk te specifieren</li><li>Hogere ontwikkelingskosten en meer tijd nodig om te ontwikkelen.</li><li>Vereist kennis van programmeren of scripting.<br></li><li>Geen natuurlijke interactie mogelijk</li><li>Kan gebruikers misleiden om te denken dat het prototype het echte product is.</li><li>Focus op details kan gebruikers \"blind\" maken voor andere aspecten.</li>"
        },
        {
            question: "Wat is een storyboard in de context van prototyping?",
            answer: "Een storyboard bestaat uit snapshots van de interface op sleutelpunten in de interactie, vaak gecombineerd met een geschreven scenario om te laten zien hoe de gebruiker een taak kan uitvoeren."
        },
        {
            question: "Wat is het Wizard of Oz-prototypingmodel?",
            answer: "Het Wizard of Oz-model houdt in dat mensen het systeem simuleren en interageren met de gebruiker, waarbij de gebruikersinterface op een geloofwaardige manier reageert op gebruikersinput."
        },
        {
            question: "Website kenmerken",
            answer: "<li>Bevat inhoud zoals teksten, afbeeldingen en video's.</li><li>Stimuleren van browsen en zoeken.</li><li>Aantrekken en behouden van bezoekers.</li><li>Bevat vaak veel tekst en informatie over verschillende onderwerpen.</li>"
        },
        {
            question: "Webapplicatie kenmerken",
            answer: "<li>Bevat taakgerichte formulieren en functionaliteiten.</li><li>Faciliteren van snelle en gemakkelijke methoden voor specifieke taken.</li><li>Bevat zeer weinig tekst en richt zich op gebruikersinteracties.</li>"
        },
        {
            question: "aspecten website",
            answer: "<li>Inhoud: Welke informatie is nodig en welke onderwerpen worden behandeld.</li><li>Navigatie: Hoofd- en subthema's, lineaire en frequente taken, gerelateerde onderwerpen via hyperlinks.</li><li>Gebruikersondersteuning: Welke hulp hebben gebruikers nodig en hoe worden de taken georganiseerd.</li>"
        },
        {
            question: "aspecten webapplicatie",
            answer: "<li>Taakgerichte formulieren: Specifieke acties en functionaliteiten die gebruikers uitvoeren.</li><li>Navigatie: Snelle navigatie tussen formulieren, unieke paginatitels.</li><li>Gebruikersondersteuning: Contextgevoelige hulp, systeemmeldingen, en links naar meer informatie.</li>"
        },
        {
            question: "Navigatie en Gebruikersinterface Website",
            answer: "<li>Bezochte links kunnen verschillende kleuren hebben.</li><li>Gebruik van frames en grotere, minder frequente pagina's.</li><li>Unieke paginatitels per pagina.</li><li>Aanbeveling: Gebruik hyperlinks om snelle navigatie tussen gerelateerde onderwerpen te ondersteunen</li>"
        },
        {
            question: "Navigatie en Gebruikersinterface Webapplicatie",
            answer: "<li>Links hebben dezelfde kleur voor consistentie.</li><li>Snelle navigatie tussen verschillende formulieren met consistente paginatitels.</li><li>Aanbeveling: Ondersteunt snelle navigatie tussen formulieren en zorgt voor consistentie in de gebruikerservaring.</li>"
        },
        {
            question: "Usability Testing en Browserondersteuning Website",
            answer: "<li>Scrollen door een klein aantal grote pagina's.</li><li>Ondersteuning van verschillende browsers met vrijheid van keuze voor gebruikers.</li><li>Gebruik van pulldown navigatiemenu's om SNAFU (System not a Friendly User) situaties te voorkomen.</li>"
        },
        {
            question: "Usability Testing en Browserondersteuning Webapplicatie",
            answer: "<li>Scrollen door een groot aantal kleine pagina's.</li><li>Ondersteuning van alle browsers met alternatieve oplossingen voor onverwachte resultaten.</li><li>Gebruik van browserknoppen en navigatiemogelijkheden om de gebruikersvrijheid te waarborgen.</li>"
        },
        {
            question: "Home Page Website",
            answer: "<li>Beschrijving van verschillende inhoudsgebieden en het hoofdmenu.</li><li>Mogelijkheid tot het weergeven van nieuwe verhalen, productoverzichten, en advertentie-inhoud.</li><li>Overweeg downloadtijd, gemakkelijke navigatie en het doel van de website bij het beslissen over de aanwezigheid en inhoud van de homepagina.</li>"
        },
        {
            question: "Home Page Webapplicatie",
            answer: "<li>Kan bestaan uit niets of geen specifieke homepagina.</li><li>Focus op directe toegang tot functionaliteiten zonder een informatieve homepagina.</li>"
        },
        {
            question: "Help en Ondersteuning Website",
            answer: "<li>Bevat FAQ's, traditionele online hulp, welkom/overzicht, over de applicatie, site map.</li><li>Bied contextgevoelige hulp en systeemmeldingen.</li><li>Links naar meer informatie over het gebruik van de website.</li>"
        },
        {
            question: "Help en Ondersteuning Webapplicatie",
            answer: "Vergelijkbare ondersteuning met nadruk op contextgevoelige hulp en systeemmeldingen om gebruikers effectief te begeleiden bij het uitvoeren van taken."
        },
        {
            question: "Doel en gebruikersbehoeften website",
            answer: "Voor informatieve en marketingdoeleinden.<br>Aantrekken en informeren van bezoekers."
        },
        {
            question: "Doel en gebruikersbehoeften Webapplicatie",
            answer: "Interactieve taken en gebruikersinteracties.<br>Faciliteren van specifieke gebruikersacties en taken"
        },
        {
            question: "Wat is de MoSCoW-methode?",
            answer: "De MoSCoW-methode is een techniek om de vereisten van een project te prioriteren. Hierbij worden de vereisten ingedeeld en toegewezen met de letters M, S, C of W."
        },
        {
            question: "Waar staat elke letter in MoSCoW voor?",
            answer: "<li>M: Must have</li><li>S: Should have</li><li>C: Could have</li><li>W: Would like to have but won't this time</li>"
        },
        {
            question: "Must have this",
            answer: "Deze vereiste moet in het eindresultaat aanwezig zijn voor het succes van het project."
        },
        {
            question: "Should have this if at all possible",
            answer: "Deze vereiste is zeer wenselijk of een equivalente oplossing is minimaal acceptabel."
        },
        {
            question: "Could have this if it does not affect anything else",
            answer: "Deze vereiste kan worden aangepakt als de belangrijkere vereisten niet in het gedrang komen; het zijn nice-to-have functies."
        },
        {
            question: "Would like to have but won't have this time around",
            answer: "Deze vereiste valt buiten de scope van het huidige project, maar kan een idee zijn voor een toekomstig project."
        },
        {
            question: "Waarom is het belangrijk om vereisten te prioriteren in een project?",
            answer: "Het prioriteren van vereisten helpt bij het focussen op de meest essentiële onderdelen die nodig zijn voor het succes van het project, vooral wanneer middelen beperkt zijn."
        },
        {
            question: "Wat zijn niet-functionele vereisten?",
            answer: "Niet-functionele vereisten beschrijven hoe het systeem moet zijn en onder welke voorwaarden de functionele vereisten moeten worden geïmplementeerd. Ze omvatten zaken als kwaliteitscriteria, beperkingen en prestatie-eisen, en kwantificeren minimum-, maximum- en verwachte waarden."
        },
        {
            question: "Wat is het verschil tussen functionele en niet-functionele vereisten?",
            answer: "Functionele vereisten beschrijven wat het systeem moet doen, zoals specifieke functies of gedragingen. Niet-functionele vereisten beschrijven hoe het systeem moet zijn, inclusief kwaliteitscriteria en operationele voorwaarden."
        },
        {
            question: "Welke vier categorieën van niet-functionele vereisten worden besproken?",
            answer: "<li>Implementatie</li><li>Externe Interface</li><li>Prestatie</li><li>Kwaliteitsvereisten</li>"
        },
        {
            question: "Wat omvatten implementatievereisten?",
            answer: "Implementatievereisten beschrijven de beperkingen op het gebied van ontwerp en implementatie, zoals gebruikte hardware/systemsoftware, programmeertaal, framework, type en specifieke database (bijv. MySQL, Oracle), en kenmerken van ontwikkelings- en productieplatforms."
        },
        {
            question: "Wat zijn externe interfacevereisten?",
            answer: "Externe interfacevereisten specificeren of het systeem moet interfacing met externe systemen en, indien ja:<li>Welke input van andere hardware/software systemen nodig is.</li><li>Welke output naar andere hardware/software systemen wordt geleverd.</li><li>Beperkingen op het formaat voor input en output (bijv. API, bestandsformaat).</li><li>Beperkingen op het medium voor input en output (bijv. internet, kabel).</li></ul>"
        },
        {
            question: "Wat zijn prestatievereisten?",
            answer: "<li>Reactietijden: Hoe snel het systeem moet reageren op specifieke gebeurtenissen, inclusief minimale, maximale en verwachte vertragingen.</li><li>Schaalbaarheid: Het aantal gelijktijdige acties dat normaal moet kunnen plaatsvinden en hoe het systeem reageert als er meer acties zijn dan gepland.</li>"
        },
        {
            question: "Kwaliteitsvereisten voor software omvatten:",
            answer: "<li>Beveiliging: Garanderen van de vertrouwelijkheid, integriteit en beschikbaarheid (CIA) van informatie, en specificeren wat het systeem niet moet doen.</li><li>Gebruiksvriendelijkheid: Human factors, ondersteuning voor gehandicapten, gebruiksvriendelijkheid zoals sneltoetsen, menu's, muisgebruik, grotere lettertypen, en beschikbare hulp zoals contextgevoelige hulp, tutorials en gebruikershandleidingen.</li>"
        },
        {
            question: "Kwaliteitsvereisten voor hardware omvatten:",
            answer: "<li>Robuustheid: De mate van duurzaamheid en betrouwbaarheid.</li><li>Afmetingen en Gewicht: Specifieke eisen met betrekking tot grootte en gewicht.</li><li>Brandbaarheid: Eisen omtrent de brandveiligheid.</li><li>...</li>"
        },
        {
            question: "Wat staat er op de checklist voor niet-functionele vereisten?",
            answer: "<li>Implementatie</li><li>Externe Interface</li><li>Prestatie</li><li>Kwaliteitsvereisten</li>"
        },
        {
            question: "Wat zijn de laatste overwegingen met betrekking tot niet-functionele vereisten?",
            answer: "<li>Er kunnen veel andere niet-functionele vereisten relevant zijn, zoals verpakking, juridische eisen, gebruikersondersteuning, internationalisatie (beschikbaarheid in andere talen), enz.</li><li>Beschrijf alleen die niet-functionele vereisten die relevant zijn voor jouw project.</li><li>Traditioneel behoren niet-functionele vereisten tot het INFRA-domein en worden ze vaak onderschat of te laat overwogen door applicatieteams.</li>"
        },
        {
            question: "Wat is een Weighted Decision Matrix?",
            answer: "Een Weighted Decision Matrix = techniek om op een objectieve manier een keuze te maken tussen verschillende vergelijkbare oplossingen. <br>Scoresysteem: betrokken factoren worden gewogen => belangrijkheid ten opzichte van elkaar relatief gemaakt."
        },
        {
            question: "Wat zijn de stappen in de aanpak van een Weighted Decision Matrix?",
            answer: "<li>1 Schrijf de beslissing op die genomen moet worden.</li><li>2 Bepaal welke factoren in overweging moeten worden genomen.</li><li>3 Weeg het belang van de factoren ten opzichte van elkaar.</li><li>4 Lijst alle mogelijke opties op waaruit gekozen moet worden.</li><li>5 Gebruik de matrix om elke optie te scoren tegen elke factor en motiveer de scores.</li><li>6 Bereken de totale score voor elke optie.</li><li>7 Formuleer een conclusie op basis van de totaalscores.</li>"
        },
        {
            question: "Example Weighted Decision Matrix",
            answer: "<img src=/Resources/Weighted%20Decision%20Matrix.JPG alt='Weighted Decision Matrix'>"
        },
        {
            "question": "Wat is datamodellering?",
            "answer": "Datamodellering is een essentiële stap in het proces van gegevensbeheer en -analyse. Het helpt bij het organiseren, structureren en begrijpen van gegevens, zodat ze effectief kunnen worden gebruikt voor verschillende zakelijke doeleinden."
        },
        {
            "question": "Waarom is datamodellering belangrijk?",
            "answer": "Datamodellering is belangrijk omdat het de basis vormt voor applicatieontwikkeling, net zoals een kelder de basis vormt voor een huis. Het heeft een sterke invloed op het succes van een applicatie en het beheer van gegevens."
        },
        {
            "question": "Wat zijn de stappen om tot een database te komen?",
            "answer": "1. Requirements Analyse: Begrijp de behoeften van de gebruikers. 2. Conceptueel ontwerp: Creëer een hoog niveau conceptueel model met een ERD. 3. Logisch ontwerp: Vertaal het conceptuele model naar een gestructureerde database-indeling. 4. Fysiek ontwerp: Richt je op de implementatie in het gekozen DBMS. 5. Implementatie: Maak de tabellen aan en definieer relaties. 6. Data Loading: Laad echte gegevens in de database."
        },
        {
            "question": "Wat is een ERD?",
            "answer": "Een Entity Relationship Diagram (ERD) is een grafische representatie van de structuur van de database, waarbij de belangrijke entiteiten en de relaties tussen deze entiteiten worden weergegeven."
        },
        {
            "question": "Wat zijn de componenten van een ERD?",
            "answer": "Een ERD bestaat minimaal uit entiteiten, relaties en attributen. Entiteiten zijn definieerbare objecten, relaties zijn de verbindingen tussen entiteiten, en attributen zijn de eigenschappen van een entiteit."
        },
        {
            "question": "Wat zijn de verschillende notatiestijlen voor een ERD?",
            "answer": "De notatiestijlen voor een ERD omvatten Chen’s Database Notation, Crow’s Foot Database Notation, UML Database Notation, IDEF1X Database Notation, Bachman, Martin en hybride vormen."
        },
        {
            "question": "Wat is een database?",
            "answer": "Een database is een georganiseerde en gestructureerde verzameling van gegevens die elektronisch wordt opgeslagen en beheerd. Het doel is om gegevens efficiënt en betrouwbaar op te slaan, te organiseren en toegankelijk te maken."
        },
        {
            "question": "Wat is een Database Management System (DBMS)?",
            "answer": "Een DBMS is software die wordt gebruikt om een database aan te maken en te beheren. Bekende DBMS'en zijn Oracle, MySQL, SQL Server en MariaDB."
        },
        {
            "question": "Wat zijn de datatypes in een database?",
            "answer": "Generieke datatypes zijn: string (tekst), integer (gehele getallen), float (komma getallen), bool (waar/niet-waar), date (datum), time (tijd) en datetime (datum en uur)."
        },
        {
            "question": "Wat zijn samengestelde gegevens?",
            "answer": "Samengestelde gegevens zijn gegevensstructuren die uit meerdere elementen bestaan, zoals het combineren van voornaam en achternaam in één attribuut."
        },
        {
            "question": "Wat zijn berekende gegevens?",
            "answer": "Berekende gegevens zijn waarden die worden gegenereerd door een berekening op basis van andere gegevens in de database. Deze worden nooit opgeslagen in de database."
        },
        {
            "question": "Wat betekent 'Nulls Allowed' en 'Nulls Not Allowed'?",
            "answer": "'Nulls Allowed' betekent dat een attribuut nullwaarden kan bevatten, terwijl 'Nulls Not Allowed' betekent dat een attribuut een verplichte waarde moet hebben."
        },
        {
            "question": "Wat zijn de kenmerken van een goed datamodel?",
            "answer": "Duidelijk, logisch en efficiënt zijn, en moet de relaties tussen entiteiten goed weergeven."
        },
        {
            "question": "Wat is het belang van het logisch ontwerp in datamodellering?",
            "answer": "Het logisch ontwerp vertaalt het conceptuele model naar een gestructureerde en technisch haalbare database-indeling, wat essentieel is voor de implementatie."
        },
        {
            "question": "Wat is de rol van een ERD in datamodellering?",
            "answer": "Een ERD dient als communicatiemiddel tussen verschillende belanghebbenden en helpt bij het creëren van een goed georganiseerde, efficiënte en begrijpelijke database."
        },
        {
            "question": "Wat zijn integriteitsregels?",
            "answer": "Integriteitsregels zijn regels die worden toegepast op een database om de geldigheid, consistentie en nauwkeurigheid van de gegevens te waarborgen."
        },
        {
            "question": "Welke soorten integriteitsregels zijn er?",
            "answer": "Referentiële integriteit: Zorgt ervoor dat elke verwijzing naar een andere tabel geldig is. Unieke beperking: Zorgt ervoor dat een attribuut of combinatie van attributen unieke waarden bevat."
        },
        {
            "question": "Wat is een primaire sleutel?",
            "answer": "Een primaire sleutel (PK) is een attribuut of combinatie van attributen die unieke waarden bevat voor elk record in een database tabel."
        },
        {
            "question": "Wat zijn de richtlijnen voor het kiezen van een primaire sleutel?",
            "answer": "De PK moet uniek zijn. De PK mag geen waarde bevatten. De PK moet minimaal zijn. De PK mag geen null-waarde bevatten."
        },
        {
            "question": "Wat is een surrogate key?",
            "answer": "Een surrogate key is een kunstmatige, niet-inhoudelijke sleutel die specifiek wordt gemaakt om als primaire sleutel te dienen in een database-tabel."
        },
        {
            "question": "Waarom worden surrogate keys gebruikt?",
            "answer": "Ze bieden een robuuste en gestandaardiseerde manier om records te identificeren en relaties tussen tabellen vast te stellen."
        },
        {
            "question": "Wat is een alternate key?",
            "answer": "Een alternate key is een attribuut of combinatie van attributen die unieke waarden bevatten, net als de primaire sleutel, maar die ook wordt gebruikt om records te identificeren."
        },
        {
            "question": "Hoe verschilt een alternate key van een primaire sleutel?",
            "answer": "Er is slechts één primaire sleutel per tabel, terwijl er meerdere alternate keys kunnen zijn."
        },
        {
            "question": "Wat zijn de verschillende soorten relaties in een ERD?",
            "answer": "Eén op één: Een persoon heeft een identiteitsbewijs. Eén op veel: Een appartementsgebouw bestaat uit verschillende appartementen. Veel op veel: Een visser kan aan veel wedstrijden deelnemen en aan een wedstrijd kunnen vele vissers deelnemen. (tussentabel)"
        },
        {
            "question": "Wat is een foreign key?",
            "answer": "Een foreign key is een kolom of set kolommen in een tabel die verwijst naar de primaire sleutel van een andere tabel."
        },
        {
            "question": "Wat is het doel van een foreign key?",
            "answer": "Het legt een relatie tussen twee tabellen en helpt om referentiële integriteit af te dwingen."
        },
        {
            "question": "Wat is een associatie entiteit?",
            "answer": "Een associatie entiteit wordt gebruikt om een veel-op-veel relatie tussen twee tabellen te modelleren. Het bevat de vreemde sleutels van beide tabellen en fungeert als een brug tussen de twee tabellen."
        },
        {
            "question": "Wat zijn enkele belangrijke punten van de ERD checklist?",
            "answer": "Elke entiteit begint met een hoofdletter en is enkelvoudig. Elk attribuut is camelCase. Elke primaire sleutel is uniek, minimaal, mag geen waarde hebben, mag niet 0 zijn en staat bovenaan. Relaties zijn sequentieel genummerd. Een associatie entiteit bevat twee keer 1..1 optionaliteit. De FK is aan de * side van elke relatie. De FK bevat altijd de volledige PK van de 1 kant tabel. 1...1 betekent dat de FK aan de * kant is altijd NNA. 0...1 betekent dat de FK aan de * kant is altijd NA."
        },
        {
            "question": "Voorbeeld code datamodel",
            "answer": "<img src=/Resources/code%20data%20model.JPG alt='Code Data Model'>"
        },
        {
            "question": "Wat zijn veelvoorkomende fouten bij het specificeren van vreemde sleutels?",
            "answer": "Bij een verplichte relatie (1..1) moet de FK NNA zijn. Als een relatie (0..1) niet verplicht is, moet de FK NA zijn. Een FK die deel uitmaakt van de PK mag nooit leeg zijn."
        },
        {
            "question": "Standardising an Attribute",
            "answer": "<img src=/Resources/Standardising%20an%20Attribute.JPG alt='Standardising an Attribute'>"
        },
        {
            "question": "DTC: Delete of Target Cascades",
            "answer": "Het record met de corresponderende FK wordt ook verwijderd."
        },
        {
            "question": "DTR: Delete of Target Restricte",
            "answer": "Het record met de PK kan niet worden verwijderd zolang er records zijn met een overeenkomende FK."
        },
        {
            "question": "DTN: Delete of Target Nullifies",
            "answer": "De corresponderende FK wordt leeggemaakt."
        },
        {
            "question": "Wat gebeurt er met een record met een FK als de PK wordt verwijderd onder DTC?",
            "answer": "Het record met de corresponderende FK wordt ook verwijderd."
        },
        {
            "question": "Waarom kan DTC gevaarlijk zijn?",
            "answer": "Omdat je als gebruiker mogelijk onbedoeld records kunt verwijderen."
        },
        {
            "question": "Wat is de restrictie bij DTR als je een record met een PK wilt verwijderen?",
            "answer": "Het record met de PK kan niet worden verwijderd zolang er records zijn met een overeenkomende FK."
        },
        {
            "question": "Hoe kun je een record met een PK verwijderen onder DTR?",
            "answer": "Eerst moeten alle gekoppelde records met de FK worden verwijderd."
        },
        {
            "question": "Wat gebeurt er met een FK onder DTN als de PK wordt verwijderd?",
            "answer": "De corresponderende FK wordt leeggemaakt (null)."
        },
        {
            "question": "Wat is een 'soft delete' en hoe werkt het?",
            "answer": "Een 'soft delete' houdt in dat een record niet fysiek wordt verwijderd, maar inactief wordt gemaakt door een 'active' attribuut op false te zetten. Dit attribuut bepaalt of het record nog steeds mag worden gebruikt."
        },
        {
            "question": "Wat moet er worden overwogen bij het vastleggen van tijdsinformatie? Time dimension",
            "answer": "Men moet zich afvragen of alleen de actuele waarde moet worden vastgelegd of ook de waarden die in het verleden van toepassing waren. Er moet slechts één actuele waarde zijn, maar ook de waarden uit het verleden kunnen in een nieuwe entiteit worden vastgelegd."
        },
        {
            "question": "Wat zijn de drie manieren om standaardwaarden en uitzonderingen bij te houden?",
            "answer": "<ul><li>Alleen de standaardwaarde.</li><li>Alleen de uitzondering.</li><li>Zowel de standaardwaarde als de uitzondering.</li></ul>"
        },
        {
            "question": "Wat is recursie in de context van datamodellering?",
            "answer": "Recursie in datamodellering verwijst naar een situatie waarin een entiteit een relatie met zichzelf heeft. Dit kan een \"1 op veel\" of \"veel op veel\" relatie zijn. Voorbeeld manager, de persoon kan een manager zijn en ook nog veel managers boven zich hebben,...<img src=/Resources/Recursie.JPG alt='Recursie'>"
        },
        {
            "question": "Wat is \"fixed coding\" in datamodellering?",
            "answer": "Fixed coding verwijst naar het gebruik van meerdere vergelijkbare attributen binnen een entiteit die op het eerste gezicht vast lijken, maar in werkelijkheid flexibel gemodelleerd moeten worden. voorbeeld weekdagen dat er gewerkt mag worden, er kan later ook altijd nog zaterdag of zondag toegevoegd worden."
        },
        {
            "question": "Wat is het verschil tussen een supertype en een subtype?",
            "answer": "Een supertype is een algemene entiteit die gemeenschappelijke attributen bevat, terwijl subtypes specifieke attributen hebben die alleen voor die subtype gelden. Bijvoorbeeld, een \"Persoon\" is een supertype van \"Agenten\" en \"Klanten\". <img src=/Resources/Super-%20and%20Subtype.JPG alt='Super- and Subtype'>"
        },
        {
            "question": "Wat zijn de eigenschappen van het modelleren op subtype?",
            "answer": "Voordelen van modelleren op subtype zijn dat bedrijfsregels worden vastgesteld en dat er geen lege attributen of velden in een tabel zijn. Nadelen zijn dat het minder flexibel en stabiel is, en dat het zoeken naar alle supertype-verschijnselen meerdere entiteiten vereist."
        },
        {
            "question": "Wat zijn de eigenschappen van het modelleren op supertype?",
            "answer": "Voordelen van modelleren op supertype zijn flexibiliteit en eenvoud, omdat er minder entiteiten en relaties zijn. Nadelen zijn dat bedrijfsregels worden genegeerd en dat er lege velden in de tabel kunnen zijn."
        },
        {
            "question": "Welke criteria moeten worden overwogen bij de keuze tussen supertype en subtype?",
            "answer": "<ul><li>Verschil in attributen: Bij een groot verschil in specifieke attributen is modelleren op subtype de voorkeur.</li><li>Verschil in relaties: Bij een groot verschil in relaties is modelleren op subtype de voorkeur.</li><li>Veranderende rollen: Als rollen in de tijd kunnen veranderen, is modelleren op supertype de voorkeur.</li><li>Belang van bedrijfsregels versus database stabiliteit: Als bedrijfsregels belangrijker zijn, is subtype de voorkeur; als stabiliteit belangrijker is, is supertype de voorkeur.</li></ul>"
        },
        {
            "question": "Wat zijn de modellering volwassenheidsniveaus?",
            "answer": "<li>0: geen specificatie (zeer kleine projecten, anders kans op conflicten)</li><li>1: tekstuele specificaties (overeenkomst tussen ontwikkelaar en klant wat er gemaakt moet worden, kans op misverstanden)</li><li>2: tekst met diagrammen (minder misvattingen van tekst wanneer diagrammen toegevoegd worden)</li><li>3: modellen met tekst (diagrammen + tekst in pseudo code)</li><li>4: exacte modellen (1 groot model bestaande uit verschillende diagramen, 1 op 1 gelinkt met broncode)</li><li>5: alleen modellen (nergens textuele aanvullingen, niets voor interpretatie vatbaar: onbestaande)</li>"
        },
        {
            "question": "Welke diagrammen zijn er in UML 2.x",
            "answer": "<li>Use case diagram</li><li>Class diagram</li><li>Toestandmachine diagram</li><li>Sequentiediagram</li><li>Communicatiediagram</li><li>Activiteitendiagram</li><li>Componentendiagram</li><li>Implementatiediagram</li>"
        },
        {
            "question": "Wat toont een use case diagram?",
            "answer": "Het use case diagram toont hoe het systeem kan worden gebruikt door externe entiteiten zoals menselijke gebruiker <img src=/Resources/Use%20Case.JPG alt='Use Case Diagram'>"
        },
        {
            "question": "Wat toont een class diagram?",
            "answer": "Het class diagram toont de statische structuur van het softwaresysteem, weergegeven als klassen en hun relaties. <img src=/Resources/Class%20Diagram.JPG alt='Class Diagram'>"
        },
        {
            "question": "Wat is het doel van een sequentiediagram?",
            "answer": "Het sequentiediagram toont de volgorde in de tijd van de berichten die door het systeem worden verzonden en ontvangen. <img src=/Resources/Sequence%20Diagram.JPG alt='Sequence Diagram'>"
        },
        {
            "question": "Wat toont een communicatiediagram?",
            "answer": "Het communicatiediagram toont hoe de objecten samenwerken om een doel te bereiken. <img src=/Resources/Communication%20Diagram.JPG alt='Communication Diagram'>"
        },
        {
            "question": "Wat is het doel van een activiteitendiagram?",
            "answer": "Het activiteitendiagram toont de activiteiten die door een deel van het systeem worden uitgevoerd, inclusief eventuele parallelle activiteiten. <img src=/Resources/Activity%20Diagram.JPG alt='Activity Diagram'>"
        },
        {
            "question": "Wat toont een toestandmachine diagram?",
            "answer": "Het toestandmachine diagram toont de toestanden waarin een object zich kan bevinden tijdens zijn levenscyclus. <img src=/Resources/State%20Chart%20Machine%20Diagram.JPG alt='State Chart Machine Diagram'>"
        },
        {
            "question": "Wat is de functie van een componentendiagram?",
            "answer": "Het componentendiagram toont de verdeling van het gehele systeem in componenten en de relaties tussen die componenten. <img src=/Resources/Component%20Diagram.JPG alt='Component Diagram'>"
        },
        {
            "question": "Wat is de functie van een Deployment diagram?",
            "answer": "Het implementatiediagram toont hoe de softwarecomponenten worden gebruikt in een specifieke systeemconfiguratie. <img src=/Resources/Deployment%20diagram.JPG alt='Deployment Diagram'>"
        },
        {
            "question": "Wat zijn de voordelen van OO-modellering?",
            "answer": "<li>Modulaire structuur</li><li>Informatie verbergen -> lagere complexiteit</li><li>Hergebruik van code</li><li>Uitbreidbaar</li>"
        },
        {
            "question": "Wat zijn de nadelen van OO-modellering?",
            "answer": "<li>Moeilijker te ontwerpen en te programmeren</li><li>Voor kleinere programma's is klassieke programmering vaak efficiënter</li><li>Voor bepaalde doeleinden kunnen functionele talen en SQL geschikter zijn</li>"
        },
        {
            "question": "4 Belangrijke OO-principe",
            "answer": "<li>Encapsulatie</li><li>Abstractie</li><li>Overerving</li><li>Polymorfisme</li>"
        },
        {
            "question": "Wat is Encapsulatie",
            "answer": "Plaats gerelateerde gegevens en de bewerkingen die deze gegevens beïnvloeden in dezelfde klasse."
        },
        {
            "question": "Wat is Abstractie",
            "answer": "Het weglaten of verbergen van niet-relevante eigenschappen en de nadruk leggen op algemene gemeenschappelijke eigenschappen van objecten."
        },
        {
            "question": "Wat is Overerving",
            "answer": "Plaats gemeenschappelijke eigenschappen/gedragingen in een meer algemene bovenliggende klasse. Een kindklasse kan eigenschappen en methoden van de meer algemene bovenliggende klasse erven."
        },
        {
            "question": "Wat is Polymorfisme",
            "answer": "De gelijkenis van de interface van klassen en objecten, maar met verschillende implementaties."
        },
        {
            "question": "Wat is een object?",
            "answer": "Een object is iets dat een onafhankelijke bestaan leidt. Het kan worden gezien als een onafhankelijk ding, zoals een fysieke zaak (bijv. auto, stoel) of een concept (bijv. vakantie, bankrekening)."
        },
        {
            "question": "Wat is een klasse?",
            "answer": "Een klasse is een verzameling van objecten met overeenkomstige eigenschappen."
        },
        {
            "question": "Wat zijn de relaties tussen klassen?",
            "answer": "Associatie, geassocieerde klasse, aggregatie, compositie, generalisatie en erfelijkheid."
        },
        {
            "question": "Wat is een associatie?",
            "answer": "Een associatie is een structurele relatie tussen twee klassen, wat betekent dat een instantie van de ene klasse meestal gedurende zijn bestaan is geassocieerd met een instantie van de tweede klasse."
        },
        {
            "question": "Hoe wordt een associatie weergegeven in een class diagram?",
            "answer": "Een associatie wordt aangegeven door een doorlopende lijn tussen de twee klassen, met de naam van de associatie langs de lijn."
        },
        {
            "question": "Wat is een reflexieve associatie?",
            "answer": "Een reflexieve (recursieve) associatie is een relatie die een klasse met zichzelf heeft."
        },
        {
            "question": "Wat is een gerichte associatie?",
            "answer": "Een gerichte associatie is een associatie die in één richting navigeerbaar is, aangegeven door een doorlopende lijn met een pijl tussen de twee klassen. De klasse waar de pijl vertrekt kent de klasse waar de pijl aankomt, maar niet omgekeerd."
        },
        {
            "question": "Wat is een rolattribuut?",
            "answer": "Een object kan verschillende rollen spelen in verschillende associaties. De rolnaam is contextafhankelijk. <img src=/Resources/Role%20Attribute.JPG alt='Role Attribute'>"
        },
        {
            "question": "Wat is een associatieklasse?",
            "answer": "Een associatieklasse is een klasse die is geassocieerd met een associatie en wordt geïdentificeerd met de associatie. Een associatieklasse wordt aangeduid met een klassensymbool, dat met een stippellijn is verbonden aan de bijbehorende associatie. <img src=/Resources/Association%20class.JPG alt='Association Class'>"
        },
        {
            "question": "Wat is aggregatie?",
            "answer": "Aggregatie is een speciale soort associatie die aangeeft dat een of meer klassen \"deel van\" een andere klasse zijn. Het geheel en de delen kunnen onafhankelijk van elkaar bestaan. Bij aggregatie kan een onderdeel object bestaan zonder het geheel. <img src=/Resources/aggregatie.JPG alt='Aggregatie'>"
        },
        {
            "question": "Wat is compositie?",
            "answer": "Compositie is een speciale soort associatie die aangeeft dat een deel altijd toebehoort aan één geheel. Het onderdeel kan niet onafhankelijk van het geheel bestaan. <img src=/Resources/compositie.JPG alt='Compositie'>"
        },
        {
            "question": "Wat is generalisatie en overerving?",
            "answer": "Generalisatie is de classificatie van klassen op basis van identieke kenmerken. De nieuwe klasse wordt de ouderklasse genoemd, terwijl de klassen met dezelfde kenmerken de kindklassen zijn. Erfelijkheid betekent dat elke kindklasse alle eigenschappen van zijn ouderklasse erft. <img src=/Resources/inheritanceb.JPG alt='Generalisatie en Overerving'>"
        },
        {
            "question": "Wat zijn de regels voor het benoemen van een klasse in een klassediagram?",
            "answer": "De naam is altijd enkelvoudig, begint met een hoofdletter en gebruikt CamelCase."
        },
        {
            "question": "Wat zijn de regels voor het benoemen van een attribute in een klassediagram?",
            "answer": "De syntax is zichtbaarheid naam[multipliciteit] [:type][=standaardwaarde]"
        },
        {
            "question": "Wat betekent dit zichtbaarheidssymbool +",
            "answer": "publiek: is zichtbaar voor elke klasse die naar de klasse kan verwijzen."
        },
        {
            "question": "Wat betekent dit zichtbaarheidssymbool -",
            "answer": "privé: kan alleen door de klasse zelf worden gebruikt."
        },
        {
            "question": "Wat betekent dit zichtbaarheidssymbool #",
            "answer": "beschermd: is alleen zichtbaar voor de klasse zelf en voor alle subklassen EN ook zichtbaar binnen hetzelfde pakket."
        },
        {
            "question": "Wat betekent dit zichtbaarheidssymbool ~",
            "answer": "pakket: is alleen zichtbaar binnen hetzelfde pakket."
        },
        {
            "question": "Wat is een afgeleid attribuut?",
            "answer": "Een berekende waarde wordt weergegeven doordat er een / voor staat: Een afgeleid attribuut is een waarde die kan worden afgeleid van andere attributen, associaties of objecten en kan niet direct worden toegewezen."
        },
        {
            "question": "Wat zijn de naming conventions voor methoden?",
            "answer": "<li><code>isMethod</code>: voor ja/nee vragen.</li><li><code>setMethod</code>: voor het wijzigen van waarden.</li><li><code>getMethod</code>: voor het opvragen van waarden.</li><li><code>findMethod</code>: voor het ophalen van een enkel object.</li>"
        },
        {
            "question": "Wat is het verschil tussen een statisch attribuut en een normaal attribuut?",
            "answer": "Onderlijnd: Een statisch attribuut is gerelateerd aan de klasse zelf en heeft slechts één waarde voor al de objecten in de klasse, ongeacht het aantal instanties van de klasse. Intrest rate is voor al de RevolvingLoans hetzelfde <img src=/Resources/static%20attribute.JPG alt='Statisch Attribuut'>"
        },
        {
            "question": "Wat is een enumeratie? <<enumeration>>",
            "answer": "Een enumeratie is een verzameling gedefinieerde constanten. <img src=/Resources/enumeration.JPG alt='Enumeratie'>"
        },
        {
            "question": "Wat is een abstracte klasse? vb.: <i>Figure {abstract}</i>",
            "answer": "Een abstracte klasse is een klasse waarvan geen instanties kunnen bestaan en die dient om een gemeenschappelijke interface te definiëren. De klasse wordt cursief geschreven en het woord abstract kan tussen haakjes achter de klassenaam worden geplaatst. <img src=/Resources/Abstract%20class.JPG alt='Abstracte Klasse'>"
        },
        {
            "question": "Wat gebeurt er als een klasse één abstracte methode heeft?",
            "answer": "De klasse wordt een abstracte klasse en de kindklassen zijn verplicht deze methode te implementeren."
        },
        {
            "question": "Kan een abstracte klasse gewone methoden bevatten?",
            "answer": "Ja, een abstracte klasse kan gewone, concrete methoden bevatten."
        },
        {
            "question": "Wat is een interface?",
            "answer": "Een interface beschrijft hoe instanties van een klasse die de interface implementeren, toegankelijk kunnen worden gemaakt door andere objecten. <img src=/Resources/interface.JPG alt='Interface'> &quot;&lt;&lt;interface&gt;&gt;&quot; Mobile: Dit is een interface genaamd \"Mobile\". Bevat één methode: <code>+ride()</code>. De cirkel (O) rechtsboven geeft aan dat dit een interface is. Dit definieert een contract dat implementerende klassen moeten volgen. DrawerUnit: Dit is een klasse die rechts van de interface staat. De gebroken lijn met holle pijl wijst op implementatie van de interface. Car: Een klasse die de Mobile interface implementeert. De gebroken lijn met holle pijl wijst op implementatie van de interface. Dit betekent dat Car verplicht is om de <code>ride()</code> methode te implementeren. Bicycle: Heeft een cirkel (O) aan de rechterkant met label \"Mobile\". Dit suggereert dat Bicycle een mobiel object is of mobiliteit bezit."
        },
        {
            "question": "Kan een interface zelf worden geïnstantieerd?",
            "answer": "Nee, een interface wordt nooit zelf geïnstantieerd."
        },
        {
            "question": "Wat is het verschil tussen een interface en een abstracte klasse?",
            "answer": "Een interface is een contract voor het gedrag van klassen, terwijl een abstracte klasse ook implementatie kan bevatten en attributen kan hebben."
        },
        {
            "question": "Klasse naar Java voorbeeld 1",
            "answer": "<img src=/Resources/Klasse%20naar%20Java%20voorbeeld%201.JPG alt='Klasse naar Java voorbeeld 1'>"
        },
        {
            "question": "multiplicity vertalen naar Java",
            "answer": "In veel gevallen heeft een klasse niet één, maar veel meer verwijzingen naar objecten van een andere klasse. <img src=/Resources/multiplicity.JPG alt='Multiplicity'> public class Team { private ArrayList<Player> playerList; ... }"
        },
        {
            "question": "Association to Java",
            "answer": "Every mother has one or more children. Every child has a mother. <img src=/Resources/Association%20to%20Java.JPG alt='Association to Java'> public class Mother { private ArrayList<Child> children; ... } public class Child { private Mother mother; ... }"
        },
        {
            "question": "Inheritance Java",
            "answer": "<img src=/Resources/Inheritance%20Java.JPG alt='Inheritance Java'> In Java, inheritance is indicated by <i>extends</i>, for example: public class Cat <b>extends</b> Pet { }"
        },
        {
            "question": "Polymorphism Java",
            "answer": "<img src=/Resources/Polymorphism%20Java.JPG alt='Polymorphism Java'> The class Pet has a method <i>makeNoise()</i>, suppose classes Cat and Dog also have this. => overriding public class Pet { public void makeNoise() { System.out.println(\"!\"); } } public class Cat extends Pet { public void makeNoise() { System.out.println(\"Meow!\"); } } public class Dog extends Pet { public void makeNoise() { System.out.println(\"Woof!\"); } }"
        },
        {
            "question": "Abstract classes Java",
            "answer": "If a class has an abstract method, the class itself becomes abstract. You must then also put the word abstract in the header of the class: <img src=/Resources/Abstract%20classes%20Java.JPG alt='Abstract classes Java'> public abstract class Pet { public abstract void makeNoise(); } You cannot create instances of an abstract class. Abstract classes act as superclasses for subclasses that override the abstract method and provide a body."
        },
        {
            "question": "Advanced concepts in a class Java",
            "answer": "<img src=/Resources/Advanced%20concepts%20in%20a%20class%20Java.JPG alt='Advanced concepts in a class Java'> public class Loan { public static double interestRate; public double creditLimit; private ArrayList<double> withdrawings; protected static void newRate(double interest){..} void open(){..} public void redeem(double amount){..} public void withdraw(double amount) {..} private double getRemaining() {..} }"
        },
        {
            "question": "Interface Java",
            "answer": "<img src=/Resources/Interface%20Java.JPG alt='Interface Java'> public interface ActionListener { public void actionPerformed( ActionEvent e ); } public class ButtonHandler implements ActionListener { public void actionPerformed( ActionEvent e ) { } } In Java is een interface een soort klasse met alleen abstracte methoden. In een interface hoef je het woord abstract niet voor de methode te zetten. Alle methoden van een interface zijn per definitie abstract. Een klasse die een interface realiseert moet aan alle abstracte methoden van de interface een body geven."
        },
        {
            "question": "Loose coupling Java",
            "answer": "<img src=/Resources/Loose%20coupling%20Java.JPG alt='Loose coupling Java'> public class Drawingpanel { private ArrayList<Shape> shapeList; public void paintComponent(Graphics g){ .... ...shapeList[i].draw(g)...; ... } } De Drawingpanel bevat een lijst van vormen die getekend moeten worden. De Drawingpanel weet niet welke vormen getekend moeten worden, het weet alleen dat het objecten zijn die de Shape-interface implementeren (= objecten met de statische type Shape). En Drawingpanel weet dat al deze objecten de methode draw() implementeren. Drawingpanel werkt met Shape en niet direct met Rectangle, Circle, Triangle. Er is een losse koppeling tussen de Drawingpanel en de concrete klassen."
        },
        {
            "question": "Enumeration Java",
            "answer": "<img src=/Resources/Enumeration%20Java.JPG alt='Enumeration Java'> public enum Gender { male, female }"
        },
        {
            "question": "Dependency Java",
            "answer": "<img src=/Resources/Dependency%20Java.JPG alt='Dependency Java'> public class Invoice{ public void printDate() { Date today = new Date(); System.out.println(today); } } Een wat lossere vorm van een relatie tussen objecten (en dus klassen) is een afhankelijkheid. Deze ontstaat wanneer een bepaalde methode van klasse A een object van klasse B nodig heeft. De methode kan een referentie naar dat object krijgen via een parameter. De methode kan het object ook zelf aanmaken. In UML geef je een afhankelijkheid aan met een gestippelde pijl."
        },
        {
            "question": "Wat is een sequentiediagram en hoe is het gestructureerd?",
            "answer": "Een sequentiediagram is een UML-diagram dat de interacties tussen objecten in een systeem in een tijdlijn weergeeft. De tijd begint bovenaan en loopt aflopend naar beneden om de volgorde van interacties en gebeurtenissen te markeren."
        },
        {
            "question": "Welke elementen worden weergegeven in een sequentiediagram?",
            "answer": "<li><img src=/Resources/Sequence%20Diagram.JPG alt='Sequence Diagram'></li><li><strong>Actor</strong>: Een externe entiteit die interactie heeft met het systeem.</li><li><strong>Object (deelnemers)</strong>: Klassen en objecten die deelnemen aan de interactie. (blokken bovenaan.)</li><li><strong>Lifeline</strong>: De verticale stippellijn die de levensduur van een object aangeeft.</li><li><strong>Bericht</strong>: Communicatie tussen objecten, weergegeven als pijlen.</li><li><strong>Retourbericht</strong>: Optioneel bericht dat de terugkeer van een operatie aangeeft, weergegeven als pijlen met stippellijn.</li><li><strong>Frame</strong>: Bevat geconditioneerde of herhaalde interacties, extra kader rondom deel van diagram (opt, alt, loop, par, ref).</li><li><strong>Activatiebox</strong>: Geeft aan dat een object actief is tijdens een bepaalde periode (verticale balkje).</li><li><strong>Tijdbeperking</strong>: Beperkingen op de volgorde of timing van gebeurtenissen.</li><li><strong>Recursie of zelfrecursie, creatie en verwijdering</strong>: Geeft aan wanneer een object zichzelf aanroept, nieuwe objecten creëert of verwijdert.</li>"
        },
        {
            "question": "Wat is het verschil tussen synchrone en asynchrone berichten in een sequentiediagram?",
            "answer": "<li><strong>Synchrone berichten</strong>: Worden weergegeven met een volle pijl met een gevulde punt. De oproepende object wacht tot het andere object klaar is met verwerken. De voltooiing van een synchrone oproep wordt aangegeven met het retourbericht (optioneel).</li><li><strong>Asynchrone berichten</strong>: Worden weergegeven met een volle pijl met een open punt. De oproepende object wacht niet tot het andere object klaar is met verwerken en er wordt niets \"teruggestuurd\".</li>"
        },
        {
            "question": "Hoe benoem je berichten tussen objecten in een sequentiediagram?",
            "answer": "De berichten worden benoemd vanuit een intern perspectief als bevelende acties op de ontvanger, meestal in de gebiedende wijs. De afzender is dominant en de ontvanger moet gehoorzamen. Bijvoorbeeld, gebruik namen zoals <code>verzendBericht()</code> in plaats van passieve vormen."
        },
        {
            "question": "Wat zijn frames in een sequentiediagram en welke soorten frames bestaan er?",
            "answer": "<div>Frames worden gebruikt om aan te geven dat bepaalde berichten alleen onder bepaalde voorwaarden plaatsvinden. De belangrijkste soorten frames zijn:</div><ul><li><strong>opt-frame</strong>: Bevat berichten die alleen worden uitgevoerd als een bepaalde [voorwaarde] (guard) waar is, wat een optionele flow vertegenwoordigt.</li><li><strong>alt-frame</strong>: Bevat meerdere delen gescheiden door een gebroken lijn, elk met een eigen [voorwaarde]. Alleen de berichten in het deel met de waarachtige [voorwaarde] worden uitgevoerd, wat alternatieve flows vertegenwoordigt.</li><li><strong>loop-frame</strong>: Bevat berichten die meerdere keren achter elkaar kunnen voorkomen. De iteratieconditie staat in de [voorwaarde], bijvoorbeeld <code>Loop [4]</code> of <code>Loop [f incomingFlights]</code>.</li><li><strong>break fragment</strong>: Wordt uitgevoerd wanneer de voorwaarde is voldaan en de omliggende interactie wordt dan niet verder uitgevoerd.</li><li><strong>parallel flow</strong>: Geeft aan dat meerdere dingen tegelijkertijd kunnen gebeuren, wat helpt om verwarring te voorkomen bij het tekenen.</li><li><strong>referentie</strong>: Als een sequentiediagram verwijst naar een ander sequentiediagram, wordt dit aangegeven door een referentie.</li></ul>"
        },
        {
            "question": "Hoe modelleer je Creatie in een sequentiediagram?",
            "answer": "<strong>Creatie</strong>: Wordt weergegeven door een pijl die niet naar de lifeline gaat, maar naar het rechthoekje dat het nieuwe object vertegenwoordigt. <img src=/Resources/Creatie.JPG alt='Creatie'>"
        },
        {
            "question": "Hoe modelleer je Recursie of zelfrecursie in een sequentiediagram?",
            "answer": "<strong>Recursie of zelfrecursie</strong>: Wordt weergegeven door een pijl die terugwijst naar hetzelfde object, wat aangeeft dat het object een operatie aanroept op zichzelf. <img src=/Resources/Recursie%20sequence.JPG alt='Recursie'>"
        },
        {
            "question": "Hoe modelleer je Verwijdering in een sequentiediagram?",
            "answer": "<strong>Verwijdering</strong>: Wordt aangegeven met een groot, dik kruis op de lifeline van het object, wat de verwijdering of deactivering van het object aangeeft. <img src=/Resources/Verwijdering.JPG alt='Verwijdering'>"
        },
        {
            "question": "Wat is een activatiebox in een sequentiediagram en wat betekent het?",
            "answer": "<img src=/Resources/activatiebox.JPG alt='Activatiebox'> Een activatiebox geeft aan dat een object actief is gedurende een bepaalde periode, bijvoorbeeld tijdens de uitvoering van een operatie. Dit wordt weergegeven door een witte staaf langs de lifeline, die de periode aangeeft waarin het object direct of indirect acties uitvoert, bijvoorbeeld via het aanroepen van een andere operatie."
        },
        {
            "question": "Hoe geef je voorwaarden en herhalingen weer in een sequentiediagram?",
            "answer": "<img src=/Resources/Iteration%20voorwaarden.JPG alt='Iteratie Voorwaarden'> <li><strong>Voorwaarden</strong>: Worden weergegeven met een [guard] in een frame, zoals een opt-frame of alt-frame, die aangeeft onder welke voorwaarden de berichten binnen het frame worden uitgevoerd.</li><li><strong>Herhalingen (loops)</strong>: Worden weergegeven met een loop-frame waarin de [guard] de iteratieconditie specificeert, zoals <code>Loop [inneemVluchten]</code>. Dit geeft aan dat de berichten binnen het frame meerdere keren kunnen worden uitgevoerd afhankelijk van de conditie.</li>"
        },
        {
            "question": "Wanneer gebruik je een alternatieve flow (alt-frame) in een sequentiediagram?",
            "answer": "Een alternatieve flow wordt gebruikt wanneer er meerdere mogelijke scenario's zijn die kunnen plaatsvinden, afhankelijk van bepaalde voorwaarden. Elk deel van het alt-frame heeft een eigen [guard] en de berichten binnen elk deel worden alleen uitgevoerd als de corresponderende [guard] waar is. Dit helpt bij het modelleren van verschillende uitkomsten van een use case."
        },
        {
            "question": "Hoe geef je aan dat een sequentiediagram verwijst naar een ander sequentiediagram?",
            "answer": "<img src=/Resources/sequentiediagram%20verwijst.JPG alt='Sequentiediagram Verwijst'> Als een sequentiediagram een verwijzing maakt naar een ander sequentiediagram, wordt dit aangegeven door een referentie binnen het frame. Dit helpt bij het structureren van complexe interacties door ze op te splitsen in beheersbare delen."
        },
        {
            "question": "Welke voordelen bieden patronen?",
            "answer": "Patronen zijn onderhoudbaar omdat ze standaard en direct herkenbaar zijn, herbruikbaar omdat ze complete oplossingen bieden die herhaald kunnen worden, en breed toepasbaar omdat ze onafhankelijk zijn van specifieke programmeertalen."
        },
        {
            "question": "Wat zijn de eigenschappen van een patroon?",
            "answer": "Een patroon bestaat uit een naam voor communicatie, een probleemomschrijving dat het oplost, een oplossing die beschrijft hoe het probleem wordt aangepakt, en de gevolgen van het toepassen van het patroon."
        },
        {
            "question": "Wat is het Creator-patroon in GRASP?",
            "answer": "Het Creator-patroon bepaalt dat klasse A verantwoordelijk is voor het aanmaken van instanties van klasse B als klasse A objecten van klasse B bevat, registreert, intensief gebruikt, of de benodigde gegevens heeft om klasse B te maken. <img src=/Resources/Creator.JPG alt='Creator'> public class Bike{ private Wheel wheel; private Frame frame; public Bike(int wheelW, int frameL){ this.wheel = new Wheel(wheelW); this.frame = new Frame(frameL); } public class Wheel{ private int width; public Wheel(int width){ this.width = width; } public class Frame{ private int length; public Frame(int length){ this.length = length; } }"
        },
        {
            "question": "Noem twee situaties waarin een klasse A verantwoordelijk moet zijn voor het aanmaken van objecten van klasse B volgens het Creator-patroon.",
            "answer": "Klasse A moet verantwoordelijk zijn voor het aanmaken van klasse B als A objecten van B bevat of als A objecten van B intensief gebruikt."
        },
        {
            "question": "Wat is het Expert-patroon in GRASP?",
            "answer": "Het Expert-patroon stelt dat verantwoordelijkheden moeten worden toegewezen aan de informatie-expert, de klasse die de benodigde informatie bezit om die verantwoordelijkheid uit te voeren. public class Bike{ private Wheel wheel; private Frame frame; Public Bike(int wheelW, int frameL){ this.wheel = new Wheel(wheelW); this.frame = new Frame(frameL); } Omdat Bike binnen zichzelf de objecten Wheel en Frame aanmaakt, moet het beschikken over de kennis en de benodigde gegevens (zoals wielbreedte en framelengte) om deze objecten correct te produceren."
        },
        {
            "question": "Wat is het doel van het lage koppeling-principe in GRASP? Low Coupling",
            "answer": "Het doel is om verantwoordelijkheden zodanig toe te wijzen dat klassen zo weinig mogelijk afhankelijk zijn van andere klassen, waardoor de impact van veranderingen wordt verminderd. <img src=/Resources/Low%20coupling%20-%20polymorphism.JPG alt='Low Coupling'> public class Drawing{ private ArrayList<Figure> figureList = new ArrayList<>(); public Drawing(){} public void addFigure(Figure f) { figureList.add(f); } public double getSurface(){ double surface = 0.0; for(Figure f : figureList){ surface += f.getSurface(); } return surface; } } public class Square implements Figure{ private int side; public Square(int side){ this.side = side; } public double getSurface(){ return side*side; } } public class Triangle implements Figure { private double base; private double height; public Triangle(double base, double height){ this.base = base; this.height = height; } public double getSurface(){ return base*height/2; } } public interface Figure{ public double getSurface(); }"
        },
        {
            "question": "Waarvoor staat GRASP?",
            "answer": "GRASP staat voor General Responsibility Assignment Software Patterns."
        },
        {
            "question": "Wat is het doel van hoge samenhang in het ontwerp van klassen?",
            "answer": "Het doel is om klassen begrijpelijk en onderhoudbaar te houden door verantwoordelijkheden te organiseren zodat ze sterk gerelateerd en consistent zijn binnen de klasse."
        },
        {
            "question": "Wat doet de controller in GRASP",
            "answer": "<li>De UI stuurt klantverzoeken door naar de controller</li><li>De controller stuurt verzoeken door naar de juiste systeemobjecten</li><li>Dit vermindert de koppeling van de UI aan systeemobjecten</li><li>Dit stelt de UI in staat te veranderen zonder het systeem te beïnvloeden</li><li>De UI mag nooit logica afhandelen of als controller fungeren (beperkt hergebruik)</li><li>De UI mag geen systeemgebeurtenissen afhandelen</li><li>Als je controller overbelast is, maak er dan meerdere die verschillende delen van de UI vertegenwoordigen</li>"
        },
        {
            "question": "Wat zijn de tekenen van een overbelaste controller in een systeem?",
            "answer": "Een overbelaste controller heeft meestal slechts één controller die te veel systeemgebeurtenissen ontvangt, voert taken zelf uit in plaats van te delegeren, en heeft veel attributen en informatie over het systeem of domein."
        },
        {
            "question": "Wat zijn mogelijke oplossingen voor overbelaste controllers?",
            "answer": "Voeg extra controllers toe om de verantwoordelijkheid te verdelen en ontwerp de controllers om werk te delegeren aan geschikte domeinklassen in plaats van alles zelf te doen."
        },
        {
            "question": "Wat beschrijft een state diagram in UML?",
            "answer": "Een state diagram beschrijft hoe een systeem zich gedraagt en reageert op gebeurtenissen, of hoe een enkel object zich gedraagt en reageert op gebeurtenissen."
        },
        {
            "question": "Welke elementen bevat een state diagram?",
            "answer": "<li><strong>Staten:</strong> Een logische naam voor de staat waarin een systeem of object zich op een bepaald moment bevindt.</li><li><strong>Transities:</strong> Veranderingen van de ene staat naar de andere.</li>"
        },
        {
            "question": "Wat zijn de initiële en finale staat in een state diagram?",
            "answer": "<li><strong>Initiële staat:</strong> De begintoestand van het systeem of object.</li><li><strong>Finale staat:</strong> De eindtoestand waarin het systeem of object zich bevindt wanneer het proces is voltooid.</li><li><img src=/Resources/initiële%20en%20finale%20staat.JPG alt='Initiële en Finale Staat'></li>"
        },
        {
            "question": "Wat zijn de drie types activiteiten in een state diagram?",
            "answer": "<img src=/Resources/activiteiten.JPG alt='Activiteiten'><br><li><strong>Ingangsactiviteiten:</strong> Uitgevoerd wanneer een staat wordt betreden vanuit een andere staat.</li><li><strong>Doelactiviteiten:</strong> Worden één of meerdere keren uitgevoerd terwijl het systeem of object zich in de staat bevindt.</li><li><strong>Uitgangsactiviteiten:</strong> Uitgevoerd wanneer een staat wordt verlaten en overgaat naar een andere staat.</li>"
        },
        {
            "question": "Wat is een transitie en hoe wordt deze genoteerd in een state diagram?",
            "answer": "<li><strong>Transitie:</strong> Verandering van de ene staat naar een andere, meestal als gevolg van een gebeurtenis.</li><li><strong>Zelftransitie:</strong> Een transitie waarbij het systeem of object binnen dezelfde staat blijft.</li><li><strong>Notatie:</strong> <code>gebeurtenisnaam (optionele parameters) [voorwaarde] / actie</code></li>"
        },
        {
            "question": "Wat zijn sub-staten en wat is het voordeel hiervan?",
            "answer": "<li><strong>Sub-staten:</strong> Staten die onderdeel zijn van een overkoepelende staat. Bijvoorbeeld, 'full' en 'half-full' kunnen sub-staten zijn van de staat 'drinkable'.</li><li><strong>Voordeel:</strong> Je hoeft niet dezelfde transitie vanuit elke sub-staat te tekenen naar dezelfde andere staat, wat het diagram eenvoudiger maakt.</li><li><img src=/Resources/sub-staten.JPG alt='Sub-staten'></li>"
        },
        {
            "question": "Welke stappen volg je bij het maken van een state diagram?",
            "answer": "<li><strong>Identificeer de staten:</strong> Bepaal de verschillende staten waarin een object kan verkeren.</li><li><strong>Vind de transities:</strong> Voor elke gebeurtenis, identificeer de bijbehorende transitie(s).</li><li><strong>Voeg start en eind staten toe:</strong> Indien nodig, voeg een initiële en finale staat toe.</li><li><strong>Voeg acties toe:</strong> Bepaal welke acties worden uitgevoerd tijdens de transities.</li><li><strong>Voeg activiteiten toe:</strong> Identificeer activiteiten die in de staten plaatsvinden.</li><li><strong>Voeg overige informatie toe:</strong> Bijvoorbeeld voorwaarden (guards) of andere relevante details.</li><li><strong>Itereer:</strong> Herzie en verfijn de bovenstaande stappen om het diagram te optimaliseren.</li>"
        },
        {
            "question": "Wat beschrijft een state diagram in UML?",
            "answer": "Een state diagram beschrijft hoe een systeem zich gedraagt en reageert op gebeurtenissen, of hoe een enkel object zich gedraagt en reageert op gebeurtenissen."
        },
        {
            "question": "Welke elementen bevat een state diagram?",
            "answer": "<li><strong>Staten:</strong> Een logische naam voor de staat waarin een systeem of object zich op een bepaald moment bevindt.</li><li><strong>Transities:</strong> Veranderingen van de ene staat naar de andere.</li>"
        },
        {
            "question": "Wat zijn de initiële en finale staat in een state diagram?",
            "answer": "<li><strong>Initiële staat:</strong> De begintoestand van het systeem of object.</li><li><strong>Finale staat:</strong> De eindtoestand waarin het systeem of object zich bevindt wanneer het proces is voltooid.</li><li><img src=\"/Resources/initiële en finale staat.JPG\" alt='Initiële en Finale Staat'></li>"
        },
        {
            "question": "Wat zijn de drie types activiteiten in een state diagram?",
            "answer": "<img src=\"/Resources/activiteiten.JPG\" alt='Activiteiten'><br><li><strong>Ingangsactiviteiten:</strong> Uitgevoerd wanneer een staat wordt betreden vanuit een andere staat.</li><li><strong>Doelactiviteiten:</strong> Worden één of meerdere keren uitgevoerd terwijl het systeem of object zich in de staat bevindt.</li><li><strong>Uitgangsactiviteiten:</strong> Uitgevoerd wanneer een staat wordt verlaten en overgaat naar een andere staat.</li>"
        },
        {
            "question": "Wat is een transitie en hoe wordt deze genoteerd in een state diagram?",
            "answer": "<li><strong>Transitie:</strong> Verandering van de ene staat naar een andere, meestal als gevolg van een gebeurtenis.</li><li><strong>Zelftransitie:</strong> Een transitie waarbij het systeem of object binnen dezelfde staat blijft.</li><li><strong>Notatie:</strong> <code>gebeurtenisnaam (optionele parameters) [voorwaarde] / actie</code></li>"
        },
        {
            "question": "Wat zijn sub-staten en wat is het voordeel hiervan?",
            "answer": "<li><strong>Sub-staten:</strong> Staten die onderdeel zijn van een overkoepelende staat. Bijvoorbeeld, 'full' en 'half-full' kunnen sub-staten zijn van de staat 'drinkable'.</li><li><strong>Voordeel:</strong> Je hoeft niet dezelfde transitie vanuit elke sub-staat te tekenen naar dezelfde andere staat, wat het diagram eenvoudiger maakt.</li><li><img src=\"/Resources/sub-staten.JPG\" alt='Sub-staten'></li>"
        },
        {
            "question": "Welke stappen volg je bij het maken van een state diagram?",
            "answer": "<li><strong>Identificeer de staten:</strong> Bepaal de verschillende staten waarin een object kan verkeren.</li><li><strong>Vind de transities:</strong> Voor elke gebeurtenis, identificeer de bijbehorende transitie(s).</li><li><strong>Voeg start en eind staten toe:</strong> Indien nodig, voeg een initiële en finale staat toe.</li><li><strong>Voeg acties toe:</strong> Bepaal welke acties worden uitgevoerd tijdens de transities.</li><li><strong>Voeg activiteiten toe:</strong> Identificeer activiteiten die in de staten plaatsvinden.</li><li><strong>Voeg overige informatie toe:</strong> Bijvoorbeeld voorwaarden (guards) of andere relevante details.</li><li><strong>Itereer:</strong> Herzie en verfijn de bovenstaande stappen om het diagram te optimaliseren.</li>"
        },
        {
            "question": "Welke UML-diagrammen worden gebruikt in de requirements fase?",
            "answer": "<strong>use case diagram</strong>"
        },
        {
            "question": "Welke UML-diagrammen behoren tot de statische fase?",
            "answer": "Het klassen diagram."
        },
        {
            "question": "Welke UML-diagrammen vallen onder de dynamische categorie?",
            "answer": "Het <strong>sequence diagram</strong>, <strong>state machine diagram</strong> en eventueel het <strong>activiteitendiagram</strong>."
        },
        {
            "question": "Welke diagrammen worden gebruikt in de implementatiefase?",
            "answer": "Het component diagram en het deployment diagram."
        },
        {
            "question": "Wat geeft een pijl tussen twee UML-diagrammen aan?",
            "answer": "Een pijl geeft aan dat het tweede diagram informatie nodig heeft van het eerste diagram."
        },
        {
            "question": "Wat betekent een stippellijnpijl tussen twee UML-diagrammen?",
            "answer": "Het eerste diagram beïnvloedt het tweede diagram zonder dat onderdelen van het tweede diagram direct uit het eerste diagram komen."
        },
        {
            "question": "Welk diagram is het centrale diagram in de methode en wordt door verschillende fasen heen ontwikkeld?",
            "answer": "Het klassen diagram."
        },
        {
            "question": "Welke fasen zijn er in projectfasering?",
            "answer": "<li><strong>Concept fase</strong> – Use case diagram.</li><li><strong>Analyse fase</strong> – Klassen diagram en sequence diagram.</li><li><strong>Design fase</strong> – State machine diagram en activiteitendiagram.</li><li><strong>Implementatie fase</strong>.</li>"
        },
        {
            "question": "Hoe worden deze fasen uitgevoerd in de watervalmethodiek versus iteratieve methodieken?",
            "answer": "<li><strong>Watervalmethodiek</strong>: Fasen worden sequentieel uitgevoerd.</li><li><strong>Iteratieve methodieken</strong>: Kleine watervallen worden herhaaldelijk uitgevoerd in meerdere iteraties.</li>"
        },
        {
            "question": "Wat wordt geanalyseerd tijdens de domeinanalyse en de applicatie- en implementatiefase?",
            "answer": "<li><strong>Domeinanalyse</strong>: <strong>WAT</strong> het systeem doet.</li><li><strong>Applicatie- en implementatiefase</strong>: <strong>HOE</strong> het systeem werkt, inclusief computeraspecten.</li>"
        },
        {
            "question": "Wat zijn de drie stappen voor verdere ontwikkeling van diagrammen tijdens de applicatie- en implementatiefase?",
            "answer": "<li><strong>Integreren van informatie</strong> uit andere diagrammen in het klassen diagram.</li><li><strong>Verfijnen van bestaande klassen</strong> (toevoegen van diepte).</li><li><strong>Toevoegen van nieuwe klassen</strong> (uitbreiding in breedte).</li>"
        },
        {
            "question": "Hoe worden berichten uit sequence diagrams en state machine diagrams geïntegreerd in het klassen diagram?",
            "answer": "Berichten worden geïntegreerd als <strong>operaties</strong> en <strong>return waarden</strong> in het klassen diagram."
        },
        {
            "question": "Hoe beïnvloeden staten uit het state machine diagram het klassen diagram?",
            "answer": "Staten worden geïntegreerd als <strong>attribuutwaarden</strong> van een object op een gegeven moment, en als <strong>pre- en post-condities</strong> voor de operaties."
        },
        {
            "question": "Wat moet gecontroleerd worden tussen sequence diagrams en klassen diagrammen?",
            "answer": "Controleer of <strong>klassen en associaties kloppen</strong>, bijvoorbeeld dat verzenders (transmitters) de ontvangers (receivers) kunnen bereiken."
        },
        {
            "question": "Wat houdt het ontwerpen van associaties in klassen diagrammen in?",
            "answer": "Het <strong>ontwerpen van navigatie</strong> tussen klassen."
        },
        {
            "question": "Welke aspecten zijn belangrijk bij het ontwerpen van attributen in het klassen diagram?",
            "answer": "<li><strong>Type</strong> van het attribuut (bijvoorbeeld utility classes).</li><li><strong>Waardebereik</strong>.</li>"
        },
        {
            "question": "Wat staat MVC voor en welke technologieën worden genoemd voor een Java project?",
            "answer": "MVC staat voor <strong>Model-View-Controller</strong>. Een voorbeeld Java project gebruikt <strong>Spring Boot</strong>, <strong>Thymeleaf</strong> en <strong>JPA</strong>."
        },
        {
            "question": "Wat is de rol van de Controller in MVC?",
            "answer": "De <strong>Controller</strong> verwerkt HTTP-verzoeken, toont nieuwe views, laadt en stuurt modellen, en scheidt de businesslogica van de schermimplementatie."
        },
        {
            "question": "Wat is het voordeel van het gebruik van JpaRepository in het project?",
            "answer": "<strong>JpaRepository</strong> zorgt ervoor dat wijzigingen in objecten automatisch worden geïmplementeerd in de database, zonder dat je zelf database-operaties hoeft te schrijven."
        },
        {
            "question": "Wat is de definitie van een domeinmodel in de context van een applicatie?",
            "answer": "Een domeinmodel is de representatie van de werkelijkheid in je applicatie, inclusief de businesslogica. Het beschrijft de concepten, relaties en regels die relevant zijn voor het specifieke domein van de applicatie."
        }
    ];

    let askedQuestions = new Map();
    let currentQuestionIndex;
    let questionsAnswered = 0;

    function initializeQuestions() {
        questions.forEach((_, index) => askedQuestions.set(index, 0));
        document.getElementById('questionsStatus').textContent = `0 van ${questions.length}`;
        nextQuestion();
    }

    function selectNextQuestion() {
        const minAsked = Math.min(...Array.from(askedQuestions.values()));
        const eligibleQuestions = Array.from(askedQuestions.entries())
            .filter(([_, count]) => count === minAsked);
        return eligibleQuestions[Math.floor(Math.random() * eligibleQuestions.length)][0];
    }

    function showAnswer() {
        const answerElement = document.getElementById('answer');
        answerElement.style.display = 'block';
        answerElement.innerHTML = questions[currentQuestionIndex].answer; // Use innerHTML instead of textContent
    }

    function updateProgress() {
      const minAsked = Math.min(...Array.from(askedQuestions.values()));
      const currentRoundQuestions = Array.from(askedQuestions.values())
              .filter(count => count === minAsked + 1).length;
      const progress = (currentRoundQuestions / questions.length) * 100;

      document.getElementById('progress').textContent = Math.round(progress);
      document.getElementById('progressBar').style.width = progress + '%';
    }

    function checkRoundComplete() {
      const minAsked = Math.min(...Array.from(askedQuestions.values()));
      const allQuestionsAsked = Array.from(askedQuestions.values())
              .every(count => count === minAsked + 1);

      if (allQuestionsAsked) {
        updateProgress();
      }
    }

    function nextQuestion() {
      if (currentQuestionIndex !== undefined) {
        askedQuestions.set(currentQuestionIndex, askedQuestions.get(currentQuestionIndex) + 1);
        questionsAnswered++;
        document.getElementById('questionsStatus').textContent = `${questionsAnswered} van ${questions.length}`;
        updateProgress();
        checkRoundComplete();
      }

      currentQuestionIndex = selectNextQuestion();
      document.getElementById('question').textContent = questions[currentQuestionIndex].question;
      document.getElementById('answer').style.display = 'none';
      // Verwijder: setInterval(updateProgress, 1000);
    }

    // Start de quiz
    initializeQuestions();
</script>